# 프로그램 최적화의 룰

## 1. 메모리 접근 비용은 프로세서의 다른 비용들을 압도한다.
메인 메모리에서 단일 데이터 워드를 가져오는 시간에는 명령어 수백개를 실행할 수 있을 시간이다.
또한 인접한 위치의 메모리를 멀리 떨어진 메모리보다 평균적으로 더 빨리 접근가능하다.

## 2. 메모리는 한정되어있다.
가상메모리는 우리에게 무한한 메모리라는 환상을 주지만 디스크에서 메모리 블록을 검색하는 데 수십 밀리초가 소모된다.

## 3. 쓰레드 간 공유 데이터에 접근하는 속도는 공유하지 않은 값보다 휠씬 느리다.



### 문자열
c++에서 C++ 이전 문자열은 메모리를 동적으로 할당하고 표현식에서 값처럼 작동하며 내부에서 복사가 많이 이뤄진다.

#### 문자열 최적화

##### 문자열 내용을 변경하는 연산자를 사용하여 임시 문자열 제거
```c++
1 String temp  = temp + "abc"; - 의 비용과
2 String temp += "abc";의 비용은 다르다.
```

1번 코드는 임시 문자열 객체 할당 코드와 임시 문자열 객체를 생성하기 때문에 상대적으로 더 많은 연산이 이루어지게 된다.
1번 코드를 2번과 같이 바꾸기만 해도 약 13배 정도의 연산 속도 개선이 발생한다.

##### 저장공간 예약을 통한 재할당 줄이기
문자열이 내부 버퍼 크기를 초과할 경우 메모리 관리자를 통하여 새 버퍼를 가져운 후 문자열을 다시 복사하게 된다.
즉 문자열을 재할당하는 비용이 소모되는 것이다. 또한 재할당한 버퍼 크기보다 더 큰 문자열이 들어오게 되는 경우 계속해서 재할당이 이뤄질 수 밖에 없다.
그렇기 때문에 미리 복사하기 전에 reserve함수를 통하여 버퍼를 할당할 경우 조금 더 성능을 개선할 수 있다.
```
String s;
s.reserve(필요한 데이터만큼);
"""
스트링 복사 및 명령어 실행
"""
```

##### const를 통하여 문자열 인수 복사를 제거하라.
함수를 호출 시에 해당 변수를 변경하지 않을 경우 const& 를 통하여 인수의 복사를 예방할 수 있다. 하지만
이와 같은 경우 포인터 역참조가 발생하기 때문에 iterator를 통하여 역참조 비용을 절약해야한다.
```
for(auto it = s.begin();, end = s.end(); it!= end; ++it){
  /// 실행구문
  temp += *it;
}
```

